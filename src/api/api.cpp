extern "C" {
#define CAML_NAME_SPACE
#include <caml/mlvalues.h>
#include <caml/callback.h>
#include <caml/alloc.h>
}

#include "api.hpp" 

// each int errors should be generated by caml_hash_variant
// to exclude value conflicts (even it isn't from ocaml) 

#define IMPL_FILE_ERROR(NAME) \
  int Api::File::Errors::NAME() const { \
    static const int code = caml_hash_variant(#NAME); \
    return code; \
  }

IMPL_FILE_ERROR(Level_is_missing)
IMPL_FILE_ERROR(Level_is_unavailable)
IMPL_FILE_ERROR(Backup_not_found)
IMPL_FILE_ERROR(Backup_is_corrupted)
IMPL_FILE_ERROR(Name_is_empty)
IMPL_FILE_ERROR(Permission_denied)
IMPL_FILE_ERROR(File_already_exists)
IMPL_FILE_ERROR(Nothing_to_save)

ð™°ðš™ðš’::ð™µðš’ðš•ðšŽ::ð™´ðš›ðš›ðš˜ðš›ðšœ* Api::File::create_errors_node() {
  return new Api::File::Errors();
}

Api::Api() {
  _state = Val_unit;
}

bool Api::is_empty() const {
  return !Is_block(_state);
}

ð™°ðš™ðš’::ð™µðš’ðš•ðšŽ* Api::create_file_node() {
  return new File(this);
}

Api::File::File(Api* api) {
  _api = api;
}

int Api::extract_and_save_state(value caml_result) {
  // Result.Ok:
  if (Tag_val(caml_result) == 0) {
    _state = Field(caml_result, 0);
    return 0;
  }
  
  // Result.Error:
  return Int_val(Field(caml_result, 0));
}

#define CAML_FUNC(F, NAME) \
  static const value* F = NULL; \
  if (F == NULL) F = caml_named_value(NAME)

int Api::File::open_new(int level) {
  CAML_FUNC(caml_open_new, "File.open_new");
  return _api->extract_and_save_state(
    caml_callback(
      *caml_open_new,
      Val_int(level)
    )
  );
}

int Api::File::restore(int level, const char* name) {
  CAML_FUNC(caml_restore, "File.restore");
  return _api->extract_and_save_state(
    caml_callback2(
      *caml_restore,
      Val_int(level),
      caml_copy_string(name)
    )
  );
}

int Api::File::save() {
  if (_api->is_empty())
    return errors()->Nothing_to_save();
  
  CAML_FUNC(caml_save, "File.save");
  return _api->extract_and_save_state(
    caml_callback(
      *caml_save,
      _api->_state
    )
  );
}

int Api::File::save_as(const char* name) {
  if (_api->is_empty())
    return errors()->Nothing_to_save();
  
  CAML_FUNC(caml_save_as, "File.save_as");
  return _api->extract_and_save_state(
    caml_callback2(
      *caml_save_as,
      caml_copy_string(name),
      _api->_state
    )
  ); 
}
